## 事件循环

### 1.概念

`事件循环`是有关 JavaScript 执行流程的一个十分重要的概念,JavaScript 有一个基于事件循环的并发模型，事件循环负责执行代码、收集和处理事件以及执行队列中的子任务，为了更好地理解概念，我们来看下面这个案例：

```javascript
console.log(1);

setTimeout(() => {
  console.log(2);
}, 1000);
console.log(3);

//输出1、3、2
```

看完代码是不是有点懵，先让我们了解一下回调队列的概念，js 在执行的过程中，函数调用压入执行栈，而遇到定时器、ajax、onload 或者 onclick 这些事件时则会把他们放进一个回调队列（又称消息队列）里，待执行栈里的任务都清空了之后才会反过来执行回调队列里的事件。所以，我们可以很清楚地知道上方代码的输出结果依次为 1、3、2，因为 js 先把执行栈里打印 1 和 3 的语句执行完毕，把定时器事件放入回调队列，最后执行。

由此，我们可以把这种先将调用栈中的事件执行完成后再执行回调队列中事件的现象称为事件循环。

### 2.微任务和宏任务

事实上，事件循环并非单单维护一个回调队列，随着 ES6 中 Promise 的出现，回调队列被划分为更加细致的微任务队列与宏任务队列。

**_宏任务_**：浏览器规定的 setTimeout、setInterval、Ajax、DOM 事件

**_微任务_**：由 ES6 语法规定的 Promise、async、await

在执行时，先执行同步代码，遇到宏任务时候则将宏任务放入宏任务队列中,遇到微任务的时候则将微任务放入微任务列表中，当所有的同步代码执行完毕后，在将异步微任务从列表中调入线程执行，异步微任务执行完毕之后再将异步宏任务从队列中调入线程执行，一直循环到执行完毕。来看下面这个例子辅助理解：

```javascript
console.log(1);
setTimeout(() => {
  console.log(2);
});
Promise.resolve().then(() => {
  console.log(3);
});
console.log(4);

//输出1、4、3、2
```

嵌套的案例:

```javascript
console.log("1");

setTimeout(function () {
  Promise.resolve().then(() => {
    console.log("2");
  });
  console.log("3");
}, 0);

new Promise((resolve) => {
  console.log("4");
  resolve();
  setTimeout(() => console.log("5"), 0);
}).then(function () {
  console.log("6");
});

console.log("7");

//输出1、4、7、6、3、2、5
```

### 3.实战

```javascript
setTimeout(function () {
  console.log("1");
});
new Promise(function (resolve) {
  console.log("2");
  resolve();
}).then(function () {
  console.log("3");
});
console.log("4");
setTimeout(function () {
  console.log("5");
  new Promise(function (resolve) {
    console.log("6");
    new Promise(function (resolve) {
      console.log("x1");
      resolve();
    }).then(function () {
      console.log("X2");
    });
    setTimeout(function () {
      console.log("X3");
      new Promise(function (resolve) {
        console.log("X4");
        resolve();
      }).then(function () {
        console.log("X5");
      });
    });
    resolve();
  }).then(function () {
    console.log("7");
  });
});
setTimeout(function () {
  console.log("8");
});
//结果输出2,4,3,1,5,6,x1,x2,7,8,x3,x4,x5
```

##### 分析

1. settimeout 宏任务，加入宏队列【console1】
2. promise `执行`同步代码 console2
3. 遇 then，加入微任务队列{console3}
4. 同步代码`执行`console4
5. settimeout 宏任务，加入宏任务队列【console1,console5】
6. settimeout 宏任务，加入宏任务队列【console1,console5,console8】
7. main 上下文同步代码执行完毕，开始执行 main 上下文微任务，`执行`console3
8. 微任务队列清空，根据先进先出原则，开始`执行`console1
9. console1 宏任务没有产生微任务，则继续`执行`宏任务 console5
10. Promise 同步代码，`执行`console6，`执行`consolex1
11. 遇 then，加入微任务队列{consolex2}
12. 遇 settimeout 宏任务 consolex3，加入宏任务队列【console8,consolex3】
13. 遇 then，加入微任务队列{consolex2,console7}
14. console5 宏任务上下文结束，开始清空微任务队列，根据先入先出规则，`执行`consolex2
15. `执行`console7
16. 微任务队列已清空，开始`执行`下一个宏任务 console8
17. console8 没有产生微任务，则`执行`下一个宏任务 consolex3
18. 遇 promise 同步代码，`执行`consolex4
19. 遇 then，微任务 consolex5 加入微任务队列{consolex5}
20. x3 宏任务结束，开始清空微任务队列，`执行`consolex5
21. 结束

#### 疑问

引发的一个问题牵涉出的疑问: 在遇到 setTimeout 代码的时候就立即放入任务队列等到定时时间到了再执行回调 还是 等到定时结束后再将回调放入任务队列？

从上面的资料里可以知道：当定时时间到了后，才会将 setTimeout 的回调函数放入消息队列中，但是具体执行的时机并不只是由定时时间决定的，还取决于当前的执行栈、当前 event loop 的事件执行时间，所以定时时间相当于一个起步时间。

至于是如何记住各个 setTimeout 的定时时间，并在定时过后放入消息队列的，据我所知定时器调度策略比较复杂，会有专门的调度策略在合适的时间添加对应的回调任务，我个人也偏向于异步处理模块对此做了处理。
但是在日常开发中，不建议去揣测底层的运行机制会出现怎样的结果，因为 setTimeout 的执行时间是个变量，我们知道它的起步时间，但无法知道具体的执行时间，所以为了保证代码逻辑的可靠性，不要堆砌各种定时函数，尽量使用 promise 或者 async 等异步函数去保证代码的执行顺序。
